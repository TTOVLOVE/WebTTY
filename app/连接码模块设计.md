1. **一个主体（登录用户或某个游客）只有一个连接码**
2. 这个连接码**可被多个客户端同时使用**，仅用于判定“这些客户端属于谁”
3. **用户/游客都可以随时重新生成（旋转）这个连接码**；旋转后旧码立即失效，新连必须用新码（现有已连的会话是否断开可配置）

下面给你一套最小改动、可直接落地的方案（模型、API、TCP 握手、清理策略、前端要点）。你可以直接按段落替换/新增代码。

------

# 1) 数据模型（单码制 & 可旋转）

用一张表统一管理“每个主体一个码”。去掉过期/一次性等字段，改为“**永不过期，直到旋转**”。

```python
# app/models.py

class ConnectCode(db.Model):
    __tablename__ = 'connect_codes'
    id = db.Column(db.Integer, primary_key=True)

    # 仅存哈希，不存明文
    code_hash = db.Column(db.String(255), nullable=False, unique=True, index=True)

    # subject：谁拥有这个码（两选一）
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True, index=True)
    guest_session_id = db.Column(db.String(64), nullable=True, index=True)  # 无登录游客的匿名主体ID（cookie/session）

    code_type = db.Column(db.String(8), nullable=False)  # 'user' | 'guest'
    is_active = db.Column(db.Boolean, default=True, index=True)

    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    last_rotated_at = db.Column(db.DateTime, default=datetime.utcnow)
    last_used_at = db.Column(db.DateTime, nullable=True)

    __table_args__ = (
        # “一个主体一个激活码”：同一 user 或同一 guest_session 仅允许 1 条 is_active=True
        db.UniqueConstraint('user_id', 'is_active', name='uq_user_active_code'),
        db.UniqueConstraint('guest_session_id', 'is_active', name='uq_guest_active_code'),
    )
```

> 说明
>
> - **不再使用 `expires_at/used/bind_once/multi_use`**。
> - “游客主体”用一个**匿名 `guest_session_id`** 标识（服务端签发、仅存随机值，不含个人信息）。
> - **旋转**=生成新明文码→写入新哈希→把旧行 `is_active=False`（或直接更新同一行的 `code_hash`，见下文 API 选型）。

给客户端分组与归属，建议在 `Client` 上加一个外键（便于“按码聚合设备”）：

```python
# app/models.py
class Client(db.Model):
    # ... 你的原字段 ...
    connect_code_id = db.Column(db.Integer, db.ForeignKey('connect_codes.id'), nullable=True, index=True)
    connect_code = db.relationship('ConnectCode', foreign_keys=[connect_code_id])
```

> 有了 `connect_code_id`：
>
> - **用户码** → 我们仍把 `client.owner_id = user_id`；
> - **游客码** → `owner_id = None`，但能通过 `connect_code_id` 把同一游客的多台设备归组。

------

# 2) API 设计（单码 & 旋转）

## 2.1 用户码（需要登录）

- **获取/生成（若不存在则创建，存在就返回掩码或直接返回同一明文——推荐只在旋转时返回新明文）**
- **旋转**：让旧码失效、返回新码明文

```python
# app/web/routes/connect_code.py
bp = Blueprint('connect_code', __name__, url_prefix='/api/connect-codes')

def _hash_code(raw: str) -> str:
    return generate_password_hash(raw)  # 可换 argon2/bcrypt

def _gen_code(n=8) -> str:
    import secrets, string
    alphabet = string.ascii_uppercase + string.digits
    return ''.join(secrets.choice(alphabet) for _ in range(n))

@bp.route('/user/rotate', methods=['POST'])
@login_required
def rotate_user_code():
    raw = _gen_code()
    now = datetime.utcnow()

    # 先置旧的失效（若有）
    ConnectCode.query.filter_by(user_id=current_user.id, code_type='user', is_active=True)\
        .update({'is_active': False})
    db.session.flush()

    # 新建激活码（也可选择“更新同一行”风格——见下一个实现变体）
    code = ConnectCode(
        code_hash=_hash_code(raw),
        code_type='user',
        user_id=current_user.id,
        is_active=True,
        last_rotated_at=now,
    )
    db.session.add(code)
    db.session.commit()
    return jsonify({'code': raw, 'type': 'user', 'rotated_at': now.isoformat()})
```

> 变体：如果你不想保留历史，可把上一段改成**查到旧行后直接更新 `code_hash`**，而不是插入新行。两种都满足“单码制”。

## 2.2 游客码（匿名主体一个码，可旋转）

需要先给游客发一个匿名 `guest_session_id`（**HttpOnly Cookie** 或本地存储的随机 token；不含个人信息）。初次请求若无，就创建一个并下发；之后都用这个 ID 定位该游客的唯一激活码。

```python
def _ensure_guest_session_id():
    sid = request.cookies.get('guest_session_id')
    if not sid:
        sid = secrets.token_urlsafe(24)
    return sid

@bp.route('/guest/ensure', methods=['POST'])
def ensure_guest_code():
    sid = _ensure_guest_session_id()
    # 查是否已有激活码
    code = ConnectCode.query.filter_by(guest_session_id=sid, code_type='guest', is_active=True).first()
    if not code:
        # 首次创建但不返回明文（防止明文滥出），引导用 rotate 获取
        code = ConnectCode(
            code_hash=_hash_code(_gen_code()),  # 先占位，用于后续 rotate
            code_type='guest',
            guest_session_id=sid,
            is_active=True,
        )
        db.session.add(code)
        db.session.commit()

    resp = jsonify({'ok': True})
    # 设置 HttpOnly + SameSite=Lax / Secure
    resp.set_cookie('guest_session_id', sid, httponly=True, samesite='Lax', secure=True, max_age=30*24*3600)
    return resp

@bp.route('/guest/rotate', methods=['POST'])
def rotate_guest_code():
    sid = _ensure_guest_session_id()
    raw = _gen_code()
    now = datetime.utcnow()

    # 让旧码失效
    ConnectCode.query.filter_by(guest_session_id=sid, code_type='guest', is_active=True)\
        .update({'is_active': False})
    db.session.flush()

    # 写入新码
    code = ConnectCode(
        code_hash=_hash_code(raw),
        code_type='guest',
        guest_session_id=sid,
        is_active=True,
        last_rotated_at=now,
    )
    db.session.add(code)
    db.session.commit()

    resp = jsonify({'code': raw, 'type': 'guest', 'rotated_at': now.isoformat()})
    resp.set_cookie('guest_session_id', sid, httponly=True, samesite='Lax', secure=True, max_age=30*24*3600)
    return resp
```

> 游客合规点：仅存**随机 session ID + code hash +时间戳**，不存任何可识别信息；并配合清理策略（见 §4）。

------

# 3) TCP 握手（多客户端共享同一码）

**规则**：客户端连接后第一帧 `hello` 必须带 `connection_code`；服务端用哈希校验，找到**唯一激活码** → 绑定客户端归属。

```python
# app/connect_func/tcp_server.py（核心片段）

hello = _recv_json_line(conn)
if not hello or hello.get('type') != 'hello' or not hello.get('connection_code'):
    _send_error_and_close(conn, 'missing_connection_code')

raw_code = hello['connection_code']

with app.app_context():
    # 在所有 is_active=True 的码里找匹配（注意只存哈希，需逐条校验，也可加入 bloom/索引优化）
    rows = ConnectCode.query.filter_by(is_active=True).all()
    matched = None
    for r in rows:
        if check_password_hash(r.code_hash, raw_code):
            matched = r
            break
    if not matched:
        _send_error_and_close(conn, 'invalid_or_rotated_code')

    # 归属：用户码→owner_id=matched.user_id；游客码→owner_id=None，但挂上 connect_code_id
    client = Client.query.filter_by(client_id=client_id).first()
    if not client:
        client = Client(client_id=client_id)
        db.session.add(client)

    client.status = 'online'
    client.last_seen = datetime.utcnow()
    client.owner_id = matched.user_id if matched.code_type == 'user' else None
    client.connect_code_id = matched.id
    db.session.commit()

    # 打 ACK，提示模式（可用于前端 UI）
    conn.sendall(json.dumps({
        "type": "hello_ack",
        "client_id": client_id,
        "mode": matched.code_type,     # 'user' or 'guest'
    }).encode() + b'\n')
```

> **多客户端共享**：同一个 `connection_code` 校验命中**同一条** `ConnectCode` 记录，自然把多个客户端归到同一主体。
>  **旋转后**：旧码匹配不到 → 新连接会被拒；是否踢掉已连会话可选：
>
> - 需要踢：旋转时广播断开 `connect_code_id == old.id` 的客户端；
> - 不踢：已连会话继续，直到断线重连时才需要新码。

------

# 4) 数据保留与清理（游客 24h）

你的要求是“**游客离开后仅保留操作日志 24 小时，然后删干净**；用户的日志按你设定的长期策略”。实现要点：

- **“游客离开”判定**：`connect_code_id` 属于 `code_type='guest'` 的客户端全部离线，并且`ConnectCode.last_used_at`或对应客户端 `last_seen` 超过 24h。
- **清理内容**：该游客码下的 `ClientLog`（以及可选的 `Client` 行）+ `ConnectCode` 本身。
- **用户码**不受 24h 规则限制。

示例清理线程（每小时跑一次）：

```python
def cleanup_worker():
    while True:
        try:
            with app.app_context():
                cutoff = datetime.utcnow() - timedelta(hours=24)

                # 找到“游客码 & 已超过 24h 无活跃客户端”的 code
                stale_guest_codes = db.session.query(ConnectCode).filter(
                    ConnectCode.code_type=='guest',
                    ConnectCode.is_active==True,  # 仍激活但长时间无人使用
                    db.or_(ConnectCode.last_used_at < cutoff, ConnectCode.last_used_at.is_(None))
                ).all()

                for code in stale_guest_codes:
                    # 是否还有在线客户端？
                    online = db.session.query(Client.id).filter_by(connect_code_id=code.id, status='online').first()
                    if online:
                        continue  # 还有在线，不删

                    # 删日志（该码下的所有客户端）
                    client_ids = [cid for (cid,) in db.session.query(Client.id).filter_by(connect_code_id=code.id).all()]
                    if client_ids:
                        ClientLog.query.filter(ClientLog.client_id.in_(client_ids)).delete(synchronize_session=False)

                    # 可选：删除游客客户端行
                    Client.query.filter(Client.id.in_(client_ids)).delete(synchronize_session=False)

                    # 最后删除 ConnectCode
                    db.session.delete(code)

                db.session.commit()
        except Exception as e:
            print('[CLEANUP] error:', e)
        time.sleep(3600)
```

> 入口：在 `create_app` 启动时拉起该线程。
>  安全起见，你也可以在**游客码无在线客户端**时，先把 `is_active=False`，再进入 24h “宽限期”，到点彻底删除。

------

# 5) 前端/管理端交互

- **用户设置页**：
  - 显示“我的连接码（仅在旋转时显示明文一次）”与“旋转”按钮；
  - 旋转后弹出新码并提示“旧码立即失效，新连接需使用新码”。
- **游客入口页**：
  - 首次访问调用 `/api/connect-codes/guest/ensure`（写入 `guest_session_id`），再提供“生成/旋转游客码”按钮（调用 `/guest/rotate`）并展示新明文。
- **客户端启动页**：
  - 必填“连接码”（复制粘贴即可），连接时作为 `hello.connection_code` 发送。
- **设备列表页**：
  - 以 `owner_id`（用户）或 `connect_code_id`（游客）分组展示；
  - 旋转后可选提供“一键断开该码下所有在线设备”。

------

# 6) 迁移与兼容

- 迁移新增字段 & 约束（`connect_code_id`, `guest_session_id`, `is_active` 等）。
- 若你已有旧的“多码/一次性码”数据：
  - 对**用户**：保留“最近一次使用”的那条作为唯一激活码，其他全设 `is_active=False`。
  - 对**游客**：无法关联的旧码可直接清理（或统一 24h 后清理）。

------

# 7) 小结（满足你的三条）

- ✅ **一个主体一个码**：通过 unique 约束+旋转接口实现；
- ✅ **多客户端共用同一码**：握手按哈希命中同一 `ConnectCode`，客户端统一归属；
- ✅ **可重新生成**：`/user/rotate`、`/guest/rotate` 原子旋转，旧码立刻失效；
- ✅ **游客合规**：仅存随机 `guest_session_id` 与 `code_hash`，无 PII；离线 24h 后连同日志一起清理。

