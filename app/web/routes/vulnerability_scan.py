from __future__ import annotations

import os
import threading
from datetime import datetime
from io import BytesIO
from typing import Any

from flask import (
    Blueprint,
    current_app,
    jsonify,
    make_response,
    render_template,
    request,
    url_for,
)
from flask_login import current_user, login_required
from xhtml2pdf import pisa

from ...extensions import db, socketio
from ...models import VulnerabilityScanRecord
from ...services.vuln_scanner import (
    ScannerCancelled,
    ScannerError,
    ScannerNotFoundError,
    run_fscan,
)

vulnerability_scan_bp = Blueprint("vulnerability_scan", __name__)

scan_tasks: dict[str, dict[str, Any]] = {}
_lock = threading.RLock()
_registered_pdf_font: dict[str, str] = {}


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


def _absolute_path(path_value: str | None) -> str | None:
    if not path_value:
        return None
    if os.path.isabs(path_value):
        return path_value
    return os.path.abspath(os.path.join(current_app.root_path, path_value))


def _safe_path(path_value: str | None) -> str | None:
    absolute = _absolute_path(path_value)
    if not absolute:
        return None
    try:
        return os.path.relpath(absolute, current_app.root_path)
    except Exception:
        return path_value


def _build_report_url(task_id: str, fmt: str) -> str | None:
    try:
        return url_for(
            "vulnerability_scan.download_scan_report",
            task_id=task_id,
            format=fmt,
        )
    except RuntimeError:
        return None


def _record_to_dict(
    record: VulnerabilityScanRecord | None, include_raw: bool = False
) -> dict[str, Any] | None:
    if not record:
        return None
    data = record.to_dict(include_raw=include_raw)
    data["target"] = data.get("target") or data.get("target_name")
    data["results"] = data.get("results") or []
    data["vulnerabilities"] = data.get("vulnerabilities") or data["results"]
    data["report_url"] = _build_report_url(record.task_id, "html")
    data["report_pdf_url"] = _build_report_url(record.task_id, "pdf")
    data["report_txt_url"] = _build_report_url(record.task_id, "txt")
    return data


def _emit_event(user_id: int | None, payload: dict[str, Any]) -> None:
    if user_id is None:
        return
    try:
        socketio.emit("vulnerability_scan_event", payload, room=str(user_id))
    except Exception as exc:
        current_app.logger.error("[漏洞扫描] 推送事件失败: %s", exc)


def _update_record(task_id: str, **updates: Any) -> VulnerabilityScanRecord | None:
    record = VulnerabilityScanRecord.query.filter_by(task_id=task_id).first()
    if not record:
        return None
    for key, value in updates.items():
        setattr(record, key, value)
    record.updated_at = datetime.utcnow()
    try:
        db.session.commit()
    except Exception as exc:
        db.session.rollback()
        current_app.logger.error("[漏洞扫描] 更新记录失败: %s", exc)
        return None
    return record


def _update_task(task_id: str, *, emit: bool = True, **updates: Any) -> None:
    with _lock:
        task = scan_tasks.get(task_id)
        if not task:
            return
        task.update(updates)
        payload = {
            "task_id": task_id,
            "status": task.get("status"),
            "progress": task.get("progress"),
            "message": task.get("message"),
            "target": task.get("target"),
            "scan_type": task.get("scan_type"),
            "results": task.get("vulnerabilities") or [],
            "report_url": task.get("report_url"),
            "report_pdf_url": task.get("report_pdf_url"),
            "report_txt_url": task.get("report_txt_url"),
            "timestamp": datetime.utcnow().isoformat(),
        }
        user_id = task.get("user_id")
    if emit:
        _emit_event(user_id, payload)


def _load_log_lines(log_path: str | None) -> list[str]:
    absolute = _absolute_path(log_path)
    if not absolute or not os.path.exists(absolute):
        return []
    try:
        with open(absolute, "r", encoding="utf-8", errors="replace") as fh:
            return [line.rstrip("\n") for line in fh]
    except Exception as exc:
        current_app.logger.error("[漏洞扫描] 读取日志失败(%s): %s", absolute, exc)
        return []


def _iter_font_candidates() -> list[dict[str, Any]]:
    configured = current_app.config.get("PDF_FONT_CANDIDATES") or []
    single_path = current_app.config.get("PDF_FONT_PATH")
    if single_path:
        configured = [{"path": single_path, "name": None}, *configured]

    defaults = [
        {"path": "static/fonts/NotoSansSC-Regular.otf", "name": "NotoSansSC"},
        {"path": r"C:\Windows\Fonts\msyh.ttc", "name": "MicrosoftYaHei"},
        {"path": r"C:\Windows\Fonts\msyh.ttf", "name": "MicrosoftYaHei"},
        {"path": r"C:\Windows\Fonts\simhei.ttf", "name": "SimHei"},
        {"path": r"C:\Windows\Fonts\simsun.ttc", "name": "SimSun"},
        {"path": r"/usr/share/fonts/opentype/noto/NotoSansCJK-Regular.ttc", "name": "NotoSansCJK"},
        {"path": r"/usr/share/fonts/truetype/wqy/wqy-microhei.ttc", "name": "WenQuanYiMicroHei"},
        {"path": r"/usr/share/fonts/truetype/arphic/ukai.ttc", "name": "ARPLUKai"},
    ]
    return [*configured, *defaults]


def _ensure_pdf_font() -> str | None:
    from reportlab.pdfbase import pdfmetrics
    from reportlab.pdfbase.ttfonts import TTFont

    with _lock:
        cached = _registered_pdf_font.get("name")
        if cached:
            return cached

        for candidate in _iter_font_candidates():
            if not isinstance(candidate, dict):
                candidate = {"path": candidate, "name": None}

            font_path = candidate.get("path")
            if not font_path:
                continue

            if not os.path.isabs(font_path):
                font_path_abs = _absolute_path(font_path)
            else:
                font_path_abs = font_path

            if not font_path_abs or not os.path.exists(font_path_abs):
                continue

            font_name = candidate.get("name") or os.path.splitext(os.path.basename(font_path_abs))[0]
            sub_index = candidate.get("index") or 0

            try:
                tt_font = TTFont(font_name, font_path_abs, subfontIndex=sub_index)
                pdfmetrics.registerFont(tt_font)
                pdfmetrics.registerFontFamily(
                    font_name,
                    normal=font_name,
                    bold=font_name,
                    italic=font_name,
                    boldItalic=font_name,
                )
                _registered_pdf_font["name"] = font_name
                _registered_pdf_font["path"] = font_path_abs
                return font_name
            except Exception as exc:
                current_app.logger.warning("[漏洞扫描] 注册 PDF 字体失败 (%s): %s", font_path_abs, exc)

    return None


def _task_authorized(task: dict[str, Any] | None) -> bool:
    if not task:
        return False
    user_id = task.get("user_id")
    return user_id == current_user.id or current_user.is_super_admin()


def _html_to_pdf_bytes(html: str) -> bytes:
    buffer = BytesIO()
    font_name = _ensure_pdf_font()
    if font_name and "</head>" in html:
        font_style = f"""
<style>
    body {{ font-family: '{font_name}', 'Microsoft YaHei', 'PingFang SC', 'SimSun', sans-serif; }}
    table {{ font-family: '{font_name}', 'Microsoft YaHei', 'PingFang SC', 'SimSun', sans-serif; }}
</style>
"""
        html = html.replace("</head>", f"{font_style}</head>", 1)

    try:
        status = pisa.CreatePDF(html, dest=buffer)
    except TypeError as exc:
        if "usedforsecurity" not in str(exc):
            raise
        import hashlib
        from reportlab.pdfbase import pdfdoc

        original_hashlib_md5 = hashlib.md5
        original_pdfdoc_md5 = getattr(pdfdoc, "md5", hashlib.md5)

        def _md5_compat(*args, **kwargs):
            kwargs.pop("usedforsecurity", None)
            return original_hashlib_md5(*args, **kwargs)

        hashlib.md5 = _md5_compat  # type: ignore[assignment]
        pdfdoc.md5 = _md5_compat  # type: ignore[assignment]
        try:
            buffer = BytesIO()
            status = pisa.CreatePDF(html, dest=buffer)
        finally:
            hashlib.md5 = original_hashlib_md5  # type: ignore[assignment]
            pdfdoc.md5 = original_pdfdoc_md5  # type: ignore[assignment]

    if status.err:
        raise ScannerError("生成 PDF 失败")
    return buffer.getvalue()


# ---------------------------------------------------------------------------
# Page
# ---------------------------------------------------------------------------


@vulnerability_scan_bp.route("/vulnerability-scan")
@login_required
def vulnerability_scan_page():
    return render_template("dashboard/vulnerability_scan.html")


# ---------------------------------------------------------------------------
# API endpoints
# ---------------------------------------------------------------------------


@vulnerability_scan_bp.route("/api/vulnerability-scan/clients")
@login_required
def get_clients_for_scan():
    try:
        from ...models import Client
        from ...services import client_manager

        if current_user.is_super_admin():
            clients = Client.query.all()
        else:
            clients = Client.query.filter_by(owner_id=current_user.id).all()

        db_clients = {client.id: client for client in clients}
        payload: list[dict[str, Any]] = []

        for client_id, info in client_manager.client_info.items():
            client_obj = db_clients.get(info.get("db_client_id"))
            if not client_obj or not current_user.can_view_client(client_obj):
                continue

            addr = info.get("addr")
            if isinstance(addr, (list, tuple)):
                ip_addr = addr[0]
            else:
                ip_addr = addr or client_obj.ip_address or "未知"

            payload.append(
                {
                    "id": str(client_id),
                    "display_name": client_obj.hostname
                    or info.get("hostname")
                    or info.get("user")
                    or f"客户端 {client_id}",
                    "hostname": client_obj.hostname or info.get("hostname") or "未知",
                    "ip": ip_addr,
                    "os": info.get("os") or client_obj.os_type or "未知",
                    "user": info.get("user") or "未知",
                }
            )

        return jsonify({"success": True, "clients": payload})
    except Exception as exc:
        current_app.logger.exception("[漏洞扫描] 获取客户端失败: %s", exc)
        return jsonify({"success": False, "message": f"获取客户端失败: {exc}"}), 500


@vulnerability_scan_bp.route("/api/vulnerability-scan/start", methods=["POST"])
@login_required
def start_vulnerability_scan():
    try:
        data = request.get_json() or {}
        target_client_id = str(data.get("target") or "")
        scan_type = data.get("scan_type") or "basic"
        options = data.get("options") or {}

        if not target_client_id:
            return jsonify({"success": False, "message": "请选择要扫描的客户端"}), 400

        from ...models import Client
        from ...services import client_manager

        client_info = client_manager.client_info.get(target_client_id)
        if not client_info:
            return jsonify({"success": False, "message": "客户端不存在或不在线"}), 400

        db_client_id = client_info.get("db_client_id")
        client = Client.query.get(db_client_id)
        if not client or not current_user.can_view_client(client):
            return jsonify({"success": False, "message": "没有权限扫描该客户端"}), 403

        addr = client_info.get("addr")
        if isinstance(addr, (list, tuple)):
            target_ip = str(addr[0])
        else:
            target_ip = addr or client.ip_address
        if not target_ip:
            return jsonify({"success": False, "message": "无法确认客户端 IP"}), 400

        target_name = (
            client.hostname
            or client_info.get("hostname")
            or client_info.get("user")
            or f"客户端 {target_client_id}"
        )
        task_id = f"scan_{datetime.utcnow().strftime('%Y%m%d%H%M%S%f')}"
        start_time = datetime.utcnow()

        record = VulnerabilityScanRecord(
            task_id=task_id,
            user_id=current_user.id,
            client_id=target_client_id,
            db_client_id=db_client_id,
            target_name=target_name,
            target_ip=str(target_ip),
            scan_type=scan_type,
            status="running",
            progress=0,
            options=options,
            message="正在排队执行...",
            start_time=start_time,
        )
        db.session.add(record)
        db.session.commit()

        stop_event = threading.Event()
        task = {
            "status": "running",
            "progress": 5,
            "target": target_name,
            "target_client_id": target_client_id,
            "scan_type": scan_type,
            "start_time": start_time.isoformat(),
            "end_time": None,
            "results": [],
            "vulnerabilities": [],
            "message": "正在排队执行...",
            "user_id": current_user.id,
            "target_ip": str(target_ip),
            "options": options,
            "raw_output": [],
            "log_path": None,
            "report_path": None,
            "report_url": None,
            "report_pdf_url": None,
            "report_txt_url": None,
            "command": [],
            "record_id": record.id,
            "stop_event": stop_event,
        }

        worker = threading.Thread(
            target=perform_scan,
            args=(
                current_app._get_current_object(),
                task_id,
                str(target_ip),
                scan_type,
                options,
            ),
            daemon=True,
        )

        with _lock:
            scan_tasks[task_id] = task
            scan_tasks[task_id]["thread"] = worker

        worker.start()

        _emit_event(
            current_user.id,
            {
                "task_id": task_id,
                "status": "running",
                "progress": 5,
                "message": "扫描任务已启动",
                "target": target_name,
                "scan_type": scan_type,
                "timestamp": start_time.isoformat(),
            },
        )

        return jsonify({"success": True, "task_id": task_id})
    except Exception as exc:
        db.session.rollback()
        current_app.logger.exception("[漏洞扫描] 启动扫描失败: %s", exc)
        return jsonify({"success": False, "message": f"启动扫描失败: {exc}"}), 500


def perform_scan(
    app,
    task_id: str,
    target_ip: str,
    scan_type: str,
    options: dict[str, Any],
) -> None:
    with app.app_context():
        with _lock:
            task = scan_tasks.get(task_id)
            stop_event: threading.Event | None = task.get("stop_event") if task else None

        def should_stop() -> bool:
            return bool(stop_event and stop_event.is_set())

        def on_progress(progress: int, message: str) -> None:
            text = message or "扫描进行中..."
            _update_task(task_id, progress=max(progress, 10), message=text)
            _update_record(task_id, progress=max(progress, 10), message=text)

        try:
            _update_task(task_id, message="正在执行 fscan...", progress=10)
            _update_record(task_id, message="正在执行 fscan...", progress=10)

            result = run_fscan(
                target=target_ip,
                scan_type=scan_type,
                options=options,
                progress_callback=on_progress,
                stop_callback=should_stop,
            )

            findings = result.get("findings", [])
            raw_output = result.get("output", [])
            command = result.get("command", [])
            log_path = _safe_path(result.get("report_path"))
            finish = datetime.utcnow()

            msg = f"扫描完成，发现 {len(findings)} 条结果"
            _update_record(
                task_id,
                status="completed",
                progress=100,
                message=msg,
                end_time=finish,
                results=findings,
                vulnerabilities=findings,
                raw_output=raw_output,
                command=command,
                log_path=log_path,
                report_path=log_path,
            )
            _update_task(
                task_id,
                status="completed",
                progress=100,
                message=msg,
                end_time=finish.isoformat(),
                results=findings,
                vulnerabilities=findings,
                raw_output=raw_output,
                command=command,
                log_path=log_path,
                report_path=log_path,
                report_url=_build_report_url(task_id, "html"),
                report_pdf_url=_build_report_url(task_id, "pdf"),
                report_txt_url=_build_report_url(task_id, "txt"),
            )
        except ScannerCancelled:
            finish = datetime.utcnow()
            msg = "扫描已被用户停止"
            _update_record(
                task_id, status="stopped", progress=0, message=msg, end_time=finish
            )
            _update_task(
                task_id,
                status="stopped",
                progress=0,
                message=msg,
                end_time=finish.isoformat(),
            )
        except (ScannerNotFoundError, ScannerError) as exc:
            finish = datetime.utcnow()
            msg = f"扫描失败: {exc}"
            _update_record(
                task_id, status="failed", progress=0, message=msg, end_time=finish
            )
            _update_task(
                task_id,
                status="failed",
                progress=0,
                message=msg,
                end_time=finish.isoformat(),
            )
        except Exception as exc:
            finish = datetime.utcnow()
            current_app.logger.exception("[漏洞扫描] 执行异常: %s", exc)
            msg = "扫描执行过程中出现异常"
            _update_record(
                task_id, status="failed", progress=0, message=msg, end_time=finish
            )
            _update_task(
                task_id,
                status="failed",
                progress=0,
                message=msg,
                end_time=finish.isoformat(),
            )
        finally:
            with _lock:
                task = scan_tasks.get(task_id)
                if task:
                    task.pop("thread", None)
                    task.pop("stop_event", None)


@vulnerability_scan_bp.route("/api/vulnerability-scan/status/<task_id>")
@login_required
def get_scan_status(task_id: str):
    try:
        with _lock:
            task = scan_tasks.get(task_id)
        if task and _task_authorized(task):
            return jsonify(
                {
                    "success": True,
                    "status": task.get("status"),
                    "progress": task.get("progress"),
                    "message": task.get("message"),
                    "results": task.get("results") or [],
                    "vulnerabilities": task.get("vulnerabilities") or [],
                    "report_url": task.get("report_url"),
                    "report_pdf_url": task.get("report_pdf_url"),
                    "report_txt_url": task.get("report_txt_url"),
                }
            )

        record = VulnerabilityScanRecord.query.filter_by(task_id=task_id).first()
        if not record:
            return jsonify({"success": False, "message": "扫描任务不存在"}), 404
        if record.user_id != current_user.id and not current_user.is_super_admin():
            return jsonify({"success": False, "message": "没有权限查看该任务"}), 403

        data = _record_to_dict(record) or {}
        return jsonify({"success": True, **{k: data.get(k) for k in [
            "status", "progress", "message", "results", "vulnerabilities", "report_url", "report_pdf_url", "report_txt_url"
        ]}})
    except Exception as exc:
        current_app.logger.exception("[漏洞扫描] 获取状态失败: %s", exc)
        return jsonify({"success": False, "message": f"获取状态失败: {exc}"}), 500


@vulnerability_scan_bp.route("/api/vulnerability-scan/status/current")
@login_required
def get_current_scan_status():
    try:
        with _lock:
            for task_id, task in scan_tasks.items():
                if (
                    (task.get("user_id") == current_user.id)
                    or current_user.is_super_admin()
                ) and task.get("status") == "running":
                    return jsonify(
                        {
                            "success": True,
                            "scan_id": task_id,
                            "status": task.get("status"),
                            "progress": task.get("progress"),
                            "message": task.get("message"),
                            "target": task.get("target"),
                            "results": task.get("results") or [],
                            "vulnerabilities": task.get("vulnerabilities") or [],
                            "report_url": task.get("report_url"),
                            "report_pdf_url": task.get("report_pdf_url"),
                            "report_txt_url": task.get("report_txt_url"),
                        }
                    )

        query = VulnerabilityScanRecord.query.filter_by(status="running")
        if not current_user.is_super_admin():
            query = query.filter_by(user_id=current_user.id)
        record = query.order_by(VulnerabilityScanRecord.updated_at.desc()).first()
        if record:
            data = _record_to_dict(record) or {}
            return jsonify(
                {
                    "success": True,
                    "scan_id": record.task_id,
                    "status": data.get("status"),
                    "progress": data.get("progress"),
                    "message": data.get("message"),
                    "target": data.get("target"),
                    "results": data.get("results", []),
                    "vulnerabilities": data.get("vulnerabilities", []),
                    "report_url": data.get("report_url"),
                    "report_pdf_url": data.get("report_pdf_url"),
                    "report_txt_url": data.get("report_txt_url"),
                }
            )

        return jsonify({"success": False, "message": "当前没有正在进行的扫描"})
    except Exception as exc:
        current_app.logger.exception("[漏洞扫描] 获取当前扫描失败: %s", exc)
        return jsonify({"success": False, "message": f"获取状态失败: {exc}"}), 500


@vulnerability_scan_bp.route("/api/vulnerability-scan/history")
@login_required
def get_scan_history():
    try:
        if current_user.is_super_admin():
            records = VulnerabilityScanRecord.query.order_by(
                VulnerabilityScanRecord.start_time.desc(),
                VulnerabilityScanRecord.updated_at.desc(),
            ).all()
        else:
            records = (
                VulnerabilityScanRecord.query.filter_by(user_id=current_user.id)
                .order_by(
                    VulnerabilityScanRecord.start_time.desc(),
                    VulnerabilityScanRecord.updated_at.desc(),
                )
                .all()
            )

        history = {record.task_id: _record_to_dict(record) for record in records}

        with _lock:
            for task_id, task in scan_tasks.items():
                if not _task_authorized(task):
                    continue
                history[task_id] = {
                    "task_id": task_id,
                    "target": task.get("target"),
                    "target_name": task.get("target"),
                    "target_client_id": task.get("target_client_id"),
                    "target_ip": task.get("target_ip"),
                    "scan_type": task.get("scan_type"),
                    "status": task.get("status"),
                    "progress": task.get("progress"),
                    "message": task.get("message"),
                    "results": task.get("results") or [],
                    "vulnerabilities": task.get("vulnerabilities") or [],
                    "options": task.get("options") or {},
                    "start_time": task.get("start_time"),
                    "end_time": task.get("end_time"),
                    "report_url": task.get("report_url"),
                    "report_pdf_url": task.get("report_pdf_url"),
                    "report_txt_url": task.get("report_txt_url"),
                }

        ordered = sorted(
            history.values(),
            key=lambda item: item.get("start_time") or item.get("created_at") or "",
            reverse=True,
        )
        return jsonify({"success": True, "history": ordered})
    except Exception as exc:
        current_app.logger.exception("[漏洞扫描] 获取历史失败: %s", exc)
        return jsonify({"success": False, "message": f"获取历史失败: {exc}"}), 500


@vulnerability_scan_bp.route("/api/vulnerability-scan/details/<task_id>")
@login_required
def get_scan_details(task_id: str):
    try:
        with _lock:
            task = scan_tasks.get(task_id)
        if task and _task_authorized(task):
            return jsonify(
                {
                    "success": True,
                    "details": {
                        "task_id": task_id,
                        "target": task.get("target"),
                        "target_client_id": task.get("target_client_id"),
                        "scan_type": task.get("scan_type"),
                        "status": task.get("status"),
                        "progress": task.get("progress"),
                        "start_time": task.get("start_time"),
                        "end_time": task.get("end_time"),
                        "message": task.get("message"),
                        "results": task.get("results") or [],
                        "vulnerabilities": task.get("vulnerabilities") or [],
                        "options": task.get("options") or {},
                        "target_ip": task.get("target_ip"),
                        "report_url": task.get("report_url"),
                        "report_pdf_url": task.get("report_pdf_url"),
                        "report_txt_url": task.get("report_txt_url"),
                        "raw_output": task.get("raw_output") or [],
                        "command": task.get("command") or [],
                        "log_path": task.get("log_path"),
                    },
                }
            )

        record = VulnerabilityScanRecord.query.filter_by(task_id=task_id).first()
        if not record:
            return jsonify({"success": False, "message": "扫描任务不存在"}), 404
        if record.user_id != current_user.id and not current_user.is_super_admin():
            return jsonify({"success": False, "message": "没有权限查看该任务"}), 403

        data = _record_to_dict(record, include_raw=True) or {}
        data["log_path"] = record.log_path
        return jsonify({"success": True, "details": data})
    except Exception as exc:
        current_app.logger.exception("[漏洞扫描] 获取详情失败: %s", exc)
        return jsonify({"success": False, "message": f"获取详情失败: {exc}"}), 500


@vulnerability_scan_bp.route("/api/vulnerability-scan/stop/<task_id>", methods=["POST"])
@login_required
def stop_scan(task_id: str):
    try:
        with _lock:
            task = scan_tasks.get(task_id)
        record = VulnerabilityScanRecord.query.filter_by(task_id=task_id).first()

        if not task and not record:
            return jsonify({"success": False, "message": "扫描任务不存在"}), 404

        owner_id = (
            (record.user_id if record else None)
            or (task.get("user_id") if task else None)
        )
        if owner_id != current_user.id and not current_user.is_super_admin():
            return jsonify({"success": False, "message": "没有权限停止该任务"}), 403

        message = "正在尝试停止扫描，请稍候..."
        if task:
            stop_event: threading.Event | None = task.get("stop_event")
            if stop_event:
                stop_event.set()
            _update_task(task_id, status="stopping", message=message)

        _update_record(task_id, status="stopping", message=message)
        _emit_event(
            owner_id,
            {
                "task_id": task_id,
                "status": "stopping",
                "message": message,
                "target": (task or {}).get("target")
                or (record.target_name if record else None),
                "scan_type": (task or {}).get("scan_type")
                or (record.scan_type if record else None),
                "timestamp": datetime.utcnow().isoformat(),
            },
        )
        return jsonify({"success": True, "message": "停止命令已发送"})
    except Exception as exc:
        current_app.logger.exception("[漏洞扫描] 停止扫描失败: %s", exc)
        return jsonify({"success": False, "message": f"停止扫描失败: {exc}"}), 500


@vulnerability_scan_bp.route("/api/vulnerability-scan/report/<task_id>")
@login_required
def download_scan_report(task_id: str):
    fmt = (request.args.get("format") or "html").lower()

    with _lock:
        task = scan_tasks.get(task_id)
    record = VulnerabilityScanRecord.query.filter_by(task_id=task_id).first()

    if record:
        if record.user_id != current_user.id and not current_user.is_super_admin():
            return jsonify({"success": False, "message": "没有权限访问该报告"}), 403
        context = _record_to_dict(record, include_raw=True) or {}
        raw_output = context.get("raw_output") or []
        log_path = record.log_path
    elif task and _task_authorized(task):
        context = {
            "task_id": task_id,
            "target": task.get("target"),
            "scan_type": task.get("scan_type"),
            "status": task.get("status"),
            "progress": task.get("progress"),
            "start_time": task.get("start_time"),
            "end_time": task.get("end_time"),
            "message": task.get("message"),
        }
        raw_output = task.get("raw_output") or []
        log_path = task.get("log_path")
    else:
        return jsonify({"success": False, "message": "扫描任务不存在"}), 404

    if not raw_output and log_path:
        raw_output = _load_log_lines(log_path)
    results = context.get("vulnerabilities") or context.get("results") or []

    html = render_template(
        "reports/vulnerability_report.html",
        record=context,
        results=results,
        raw_output=raw_output,
        generated_at=datetime.utcnow(),
    )
    filename = f"vulnerability_report_{task_id}.{fmt}"

    if fmt == "html":
        response = make_response(html)
        response.headers["Content-Type"] = "text/html; charset=utf-8"
        response.headers["Content-Disposition"] = f'attachment; filename="{filename}"'
        return response
    if fmt == "pdf":
        pdf = _html_to_pdf_bytes(html)
        response = make_response(pdf)
        response.headers["Content-Type"] = "application/pdf"
        response.headers["Content-Disposition"] = f'attachment; filename="{filename}"'
        return response
    if fmt == "txt":
        body = "\n".join(raw_output) if raw_output else "暂无扫描输出"
        response = make_response(body)
        response.headers["Content-Type"] = "text/plain; charset=utf-8"
        response.headers["Content-Disposition"] = f'attachment; filename="{filename}"'
        return response

    return jsonify({"success": False, "message": f"不支持的导出格式: {fmt}"}), 400
